import asyncio
import os
import time

from aiogram.types import KeyboardButton, ReplyKeyboardMarkup
from aiogram import Bot, types
from aiogram.dispatcher import Dispatcher
from aiogram.utils.markdown import hbold, hlink
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from sqlalchemy import desc, select
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.asyncio import create_async_engine as _create_async_engine
from sqlalchemy.ext.asyncio import AsyncSession
from dotenv import load_dotenv

from models import Product, Price
from config import DATABASE_URI
from scrap_data.scrap_main import ScrapDataProduct

load_dotenv()


def create_async_engine(url):
    return _create_async_engine(url=url,
                                echo=True,
                                pool_pre_ping=True,
                                )


def get_session_maker(engine):
    return sessionmaker(engine, class_=AsyncSession)


async_engine = create_async_engine(DATABASE_URI)
session_maker = get_session_maker(async_engine)


async def main():
    bot = Bot(token=os.getenv('TOKEN'), parse_mode=types.ParseMode.HTML)
    storage = MemoryStorage()
    dp = Dispatcher(bot, storage=storage)

    class ChoiceLincProduct(StatesGroup):
        product_linc = State()

    class ChoiceIdProductDelete(StatesGroup):
        id_product_delete = State()

    class ChoiceIdProductPrice(StatesGroup):
        id_product_price = State()

    async def on_startup(_):
        """–î–µ–π—Å—Ç–≤–∏—è –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –±–æ—Ç–∞."""
        print('–ë–æ—Ç –≤—ã—à–µ–ª –≤ –æ–Ω–ª–∞–π–Ω...')

    async def on_shutdown(_):
        """–î–µ–π—Å—Ç–≤–∏—è –ø–æ—Å–ª–µ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–æ—Ç–∞."""
        print('–ó–∞–∫—Ä—ã–≤–∞—é —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –ë–î')

    b1 = KeyboardButton('–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Ç–æ–≤–∞—Ä–æ–≤')
    b2 = KeyboardButton('–£–¥–∞–ª–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞')
    b3 = KeyboardButton('–î–æ–±–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä –Ω–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥')
    b4 = KeyboardButton('–ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Ü–µ–Ω –Ω–∞ —Ç–æ–≤–∞—Ä')

    kb_client = ReplyKeyboardMarkup(resize_keyboard=True)

    kb_client.row(b1, b2).add(b3).add(b4)

    @dp.message_handler(commands=['start', 'help'])
    async def command_start(message: types.Message):
        """–°—Ç–∞—Ä—Ç–æ–≤—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫"""
        await message.answer(f'–î–æ–±—Ä—ã–π –¥–µ–Ω—å {message.from_user.first_name}! '
                             f'–î–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞, –Ω–∞–ø–∏—à–∏—Ç–µ —Å—Å—ã–ª–∫—É'
                             f' –Ω–∞ —Ç–æ–≤–∞—Ä.–ò–ª–∏ –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –º–µ–Ω—é ‚¨á',
                             reply_markup=kb_client,
                             )

    @dp.message_handler(
        lambda message: '–ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —Ü–µ–Ω –Ω–∞ —Ç–æ–≤–∞—Ä' in message.text)
    async def price_product(message: types.Message):
        """–ò—Å—Ç–æ—Ä–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω –Ω–∞ —Ç–æ–≤–∞—Ä."""
        await message.answer('–ù–∞–ø–∏—à–∏—Ç–µ –≤ —á–∞—Ç id —Ç–æ–≤–∞—Ä–∞ ')
        await ChoiceIdProductPrice.id_product_price.set()

    @dp.message_handler(state=ChoiceIdProductPrice.id_product_price)
    async def price_history_product(message: types.Message, state: FSMContext):
        """–ò—Å—Ç–æ—Ä–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω –Ω–∞ —Ç–æ–≤–∞—Ä."""
        await state.update_data(id_product_price=message.text)
        data = await state.get_data()
        id_price = int(data.get('id_product_price'))
        async with session_maker() as session:
            async with session.begin():
                session: AsyncSession
                result = await session.execute(
                    select(Product).where(Product.id == id_price)
                )
                product = result.one_or_none()
                if product is None:
                    await message.answer(
                        '‚ùå–¢–æ–≤–∞—Ä–∞ —Å —Ç–∞–∫–∏–º id –µ—â—ë –Ω–µ—Ç—É –≤ —Å–ø–∏—Å–∫–µ,'
                        ' —Å–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤—å—Ç–µ —Ç–æ–≤–∞—Ä')
                    await state.finish()
                else:
                    a = await session.execute(
                        select(Price).filter(
                            Price.product_id == id_price).order_by(
                            desc(Price.price_at))
                    )
                    res = a.scalars()
                    for index, product in enumerate(res):
                        card = f'{hbold("–¢–æ–≤–∞—Ä c id: ")} {id_price}\n' \
                               f'{hbold("–¶–µ–Ω–∞: ")} {product.price}üî•\n' \
                               f'{hbold("–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: ")}' \
                               f' {product.price_at}\n'

                        if index == 20:
                            break

                        await message.answer(card)
                        await state.finish()

    @dp.message_handler(
        lambda message: '–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Ç–æ–≤–∞—Ä–æ–≤' in message.text)
    async def all_product(message: types.Message):
        """–ü—Ä–æ—Å–º–æ—Ç—Ä –≤—Å–µ—Ö —Ç–æ–≤–∞—Ä–æ–≤ –Ω–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–µ."""
        await message.answer('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –ø–æ–¥–æ–∂–¥–∏—Ç–µ‚åõ...')
        async with session_maker() as session:
            async with session.begin():
                session: AsyncSession
                result = await session.execute(select(Product))
                users = result.scalars().all()
                for index, product in enumerate(users):
                    linc = hlink(product.name, product.url)
                    card = f'{hbold("–°—Å—ã–ª–∫–∞: ")} {linc}\n' \
                           f'{hbold("id: ")} {product.id}\n' \
                           f'{hbold("–†–µ–π—Ç–∏–Ω–≥: ")} {product.rating}üî•\n' \
                           f'{hbold("–ù–∞–∑–≤–∞–Ω–∏–µ: ")} {product.name}\n' \
                           f'{hbold("–û–ø–∏—Å–∞–Ω–∏–µ: ")} {product.description}\n'

                    #  –ó–∞—â–∏—Ç–∞ –æ—Ç –±–∞–Ω–∞ –∑–∞ —Ñ–ª—É–¥.
                    if index % 20 == 0:
                        time.sleep(3)

                    await message.answer(card)

    @dp.message_handler(lambda message: '–£–¥–∞–ª–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞' in message.text)
    async def delete_product_(message: types.Message):
        """–£–¥–∞–ª–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –∏–∑ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞."""
        await message.answer(
            '–ù–∞–ø–∏—à–∏—Ç–µ id —Ç–æ–≤–∞—Ä–∞ –∏–∑ –∫–∞—Ä—Ç–æ—á–∫–∏ –¥–ª—è –µ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞'
        )
        await ChoiceIdProductDelete.id_product_delete.set()

    @dp.message_handler(state=ChoiceIdProductDelete.id_product_delete)
    async def delete_product(message: types.Message, state: FSMContext):
        """–£–¥–∞–ª–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –∏–∑ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞."""
        await state.update_data(id_product_delete=message.text)
        data = await state.get_data()
        id_p = int(data.get('id_product_delete'))
        async with session_maker() as session:
            async with session.begin():
                session: AsyncSession
                await session.execute(select(Product))
                product_delete = await session.get(Product, id_p)
                await session.delete(product_delete)
                await message.answer('–¢–æ–≤–∞—Ä —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª—ë–Ω üóë')
                await state.finish()

    @dp.message_handler(
        lambda message: '–î–æ–±–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä –Ω–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥' in message.text)
    async def add_product(message: types.Message):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –Ω–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥."""
        await message.answer('–ù–∞–ø–∏—à–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–æ–≤–∞—Ä —Å —Å–∞–π—Ç–∞ –ú.–≤–∏–¥–µ–æ')
        await ChoiceLincProduct.product_linc.set()

    @dp.message_handler(state=ChoiceLincProduct.product_linc)
    async def www_par(message: types.Message, state: FSMContext):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –Ω–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥."""
        if message.text[:31] != 'https://www.mvideo.ru/products/':
            await message.answer('‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ —Ç–æ–≤–∞—Ä.')
            return
        await state.update_data(product_linc=message.text)
        data = await state.get_data()
        linc = str(data.get('product_linc'))
        product = ScrapDataProduct(linc).scrap()
        name = product['name']
        description = product['description']
        rating = product['rating']
        async with session_maker() as session:
            async with session.begin():
                session: AsyncSession
                res = await session.execute(
                    select(Product).where(Product.url == linc))
                product = res.one_or_none()
                if product is not None:
                    await message.answer(
                        '‚ùå –î–∞–Ω–Ω—ã–π —Ç–æ–≤–∞—Ä —É–∂–µ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–µ.')
                    await state.finish()
                else:
                    new_product = Product(url=linc,
                                          name=name,
                                          description=description,
                                          rating=rating,
                                          )
                    session.add(new_product)
                    await session.commit()
                    await message.answer('–¢–æ–≤–∞—Ä —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω‚úÖ')
                    await state.finish()

    @dp.message_handler()
    async def echo_send(message: types.Message):
        """–≠—Ö–æ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫."""
        await message.reply(
            '–ù–µ–≤–µ—Ä–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞, –ø—Ä–æ—á—Ç–∏—Ç–µ –µ—â—ë —Ä–∞–∑ –∫–∞–∫–æ–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–ø—Ä–æ—Å –∏'
            ' –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É...')

    await dp.start_polling(bot)


if __name__ == '__main__':
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print('Bot stopped')
